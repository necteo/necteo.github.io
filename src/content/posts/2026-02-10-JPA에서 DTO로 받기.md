---
title: 'JPA에서 DTO로 받기'
published: 2026-02-10
description: 'JPA'
pinned: false
author: 'necteo'
image: ''
tags: ['JPA', 'Oracle', 'Spring Boot']
category: 'ORM'
draft: false
---

**Entity**

```java
@Entity
@Table(name = "jejutravel")
@Data
public class JejuTravel {

		@Id
		@Column(name = "contentid")
		private int contentid;

		private int no;
		private String title;
		private String image1;
		private String image2;

		private String address;
		private double x, y;
		private int contenttype, hit;

}

@Entity
@Data
public class Attraction {

		@Id
		@Column(name = "contentid")
		private int contentid;

		private int no;
		private String infocenter, restdate, usetime, parking;

		@Lob
		@Column(name = "msg")
		private String msg;

		@OneToOne
		@JoinColumn(name = "contentid", insertable = false, updatable = false)
		JejuTravel jeju = new JejuTravel();

}
```

**DTO**

```java
public class AttractionDTO extends CommonsDetailDTO {

    private String infocenter;
    private String restdate;
    private String usetime;
    private String parking;
    private String msg;

    public AttractionDTO(int contentid, String title, String image1, String address, double x, double y,
                         int contenttype, int hit, String infocenter, String restdate,
                         String usetime, String parking, String msg) {
        super(contentid, title, image1, address, x, y, contenttype, hit);
        this.infocenter = infocenter;
        this.restdate = restdate;
        this.usetime = usetime;
        this.parking = parking;
        this.msg = msg;
    }

}
```

Join 관계에 있는 두 테이블을 엔티티로 받지 않고 DTO 클래스를 별로도 생성해서 받는다

**JPQL**

```java
@Query("SELECT new com.sist.web.dto.AttractionDTO("
		 + "a.contentid, j.title, j.image1, j.address, j.x, j.y, j.contenttype, j.hit, "
		 + "a.infocenter, a.restdate, a.usetime, a.parking, a.msg) "
		 + "FROM Attraction a "
		 + "JOIN JejuTravel j ON j.contentid = a.contentid "
		 + "WHERE j.contentid = :contentid")
public Optional<AttractionDTO> jejuAttractionDetail(@Param("contentid") int contentid);
```

**장점**

1. 중간에 Entity => DTO 변환과정도 생략할 수 있고

2. 필요한 컬럼만 조회해서 네트워크와 메모리 비용이 감소

3. JPA에서 자바 클래스로 데이터를 처리할 때 더 안전한 처리

**추가**

JPQL에서는 꼭 패키지 경로까지 써줘야 함

런타임 단계에서 클래스를 인식하기 때문에 어디에 있는지 모른다고

FROM 절의 엔티티는 컴파일 시 인식해서 클래스명만 써도 괜찮다

JpaRepository<>의 제네릭은 DTO로 받게되면 크게 상관없어지지만 중점에 따라서 메소드를 배치하면 될 것
